Object.defineProperty(exports, '__esModule', {
  value: true
});
var core = require('@urql/core');
var wonka = require('wonka');
var store = require('svelte/store');
var svelte = require('svelte');
var fromStore = store$ => wonka.make(observer => store$.subscribe(observer.next));
var initialResult = {
  fetching: false,
  stale: false,
  error: undefined,
  data: undefined,
  extensions: undefined
};
var createPausable = isPaused$ => ({
  isPaused$,
  pause() {
    isPaused$.set(true);
  },
  resume() {
    isPaused$.set(false);
  }
});
function queryStore(args) {
  var request = core.createRequest(args.query, args.variables);
  var context = {
    requestPolicy: args.requestPolicy,
    ...args.context
  };
  var operation = args.client.createRequestOperation('query', request, context);
  var initialState = {
    ...initialResult,
    operation
  };
  var result$ = store.writable(initialState, () => {
    return subscription.unsubscribe;
  });
  var isPaused$ = store.writable(!!args.pause);
  var subscription = wonka.subscribe(result => {
    result$.set(result);
  })(wonka.scan((result, partial) => ({
    ...result,
    ...partial
  }), initialState)(wonka.switchMap(isPaused => {
    if (isPaused) {
      return wonka.never;
    }
    return wonka.concat([wonka.fromValue({
      fetching: true,
      stale: false
    }), wonka.map(({
      stale,
      data,
      error,
      extensions,
      operation
    }) => ({
      fetching: false,
      stale: !!stale,
      data,
      error,
      operation,
      extensions
    }))(args.client.executeRequestOperation(operation)), wonka.fromValue({
      fetching: false
    })]);
  })(fromStore(isPaused$))));
  return {
    ...store.derived(result$, (result, set) => {
      set(result);
    }),
    ...createPausable(isPaused$)
  };
}
function mutationStore(args, handler) {
  var request = core.createRequest(args.query, args.variables);
  var operation = args.client.createRequestOperation('mutation', request, args.context);
  var initialState = {
    ...initialResult,
    operation,
    fetching: true
  };
  var result$ = store.writable(initialState);
  var subscription = wonka.subscribe(result => {
    result$.set(result);
  })(wonka.scan((result, partial) => {
    // If a handler has been passed, it's used to merge new data in
    var data = partial.data !== undefined ? typeof handler === 'function' ? handler(result.data, partial.data) : partial.data : result.data;
    return {
      ...result,
      ...partial,
      data
    };
  }, initialState)(wonka.map(({
    stale,
    data,
    error,
    extensions,
    operation
  }) => ({
    fetching: false,
    stale: !!stale,
    data,
    error,
    operation,
    extensions
  }))(args.client.executeRequestOperation(operation))));
  return store.derived(result$, (result, set) => {
    set(result);
    return subscription.unsubscribe;
  });
}
function subscriptionStore(args) {
  var request = core.createRequest(args.query, args.variables);
  var operation = args.client.createRequestOperation('subscription', request, args.context);
  var initialState = {
    ...initialResult,
    operation
  };
  var result$ = store.writable(initialState, () => {
    return subscription.unsubscribe;
  });
  var isPaused$ = store.writable(!!args.pause);
  var subscription = wonka.subscribe(result => {
    result$.set(result);
  })(wonka.scan((result, partial) => ({
    ...result,
    ...partial
  }), initialState)(wonka.switchMap(isPaused => {
    if (isPaused) {
      return wonka.never;
    }
    return wonka.concat([wonka.fromValue({
      fetching: true,
      stale: false
    }), wonka.map(({
      stale,
      data,
      error,
      extensions,
      operation
    }) => ({
      fetching: true,
      stale: !!stale,
      data,
      error,
      operation,
      extensions
    }))(args.client.executeRequestOperation(operation)), wonka.fromValue({
      fetching: false
    })]);
  })(fromStore(isPaused$))));
  return {
    ...store.derived(result$, (result, set) => {
      set(result);
    }),
    ...createPausable(isPaused$)
  };
}
var _contextKey = '$$_urql';
/** Retrieves a Client from Svelte's context */
var getContextClient = () => {
  var client = svelte.getContext(_contextKey);
  if (process.env.NODE_ENV !== 'production' && !client) {
    throw new Error('No urql Client was found in Svelte context. Did you forget to call setContextClient?');
  }
  return client;
};
/** Sets a Client on Svelte's context */
var setContextClient = client => {
  svelte.setContext(_contextKey, client);
};
/** Creates Client and adds it to Svelte's context */
var initContextClient = args => {
  var client = new core.Client(args);
  setContextClient(client);
  return client;
};
exports.getContextClient = getContextClient;
exports.initContextClient = initContextClient;
exports.mutationStore = mutationStore;
exports.queryStore = queryStore;
exports.setContextClient = setContextClient;
exports.subscriptionStore = subscriptionStore;
Object.keys(core).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return core[k];
    }
  });
});
//# sourceMappingURL=urql-svelte.js.map
